# AUTOGENERATED — DO NOT EDIT.
# Source: steeleagle.protocol.services.control_service.Control

from __future__ import annotations
from typing import Any, Mapping, Optional, List, Tuple
from dataclasses import dataclass, is_dataclass, asdict as dc_asdict
from enum import Enum
import grpc

from google.protobuf.json_format import ParseDict, MessageToDict
from google.protobuf.timestamp_pb2 import Timestamp as ProtoTimestamp

# ---------------------------------------------------------------------
# Base types
# ---------------------------------------------------------------------
from sdk.base import Action, Datatype  # <- your Action base class
from dsl.compiler.registry import register_action  # if you’re using a registry

# ---------------------------------------------------------------------
# message types
# ---------------------------------------------------------------------
from sdk.message.common import (
    Response as CommonResponse,
    ResponseStatus,
    Location, Velocity, Position, Pose
)

from sdk.message.control import (
    AltitudeMode, HeadingMode, ReferenceFrame, PoseMode
)

@dataclass
class ImagingSensorConfiguration(Datatype):

    id: int
    '''Target imaging sensor ID'''
    set_primary: bool
    '''Set this sensor as the primary stream'''
    set_fps: int
    '''Target FPS for stream'''



# ---------------------------------------------------------------------
# Raw protobuf
# ---------------------------------------------------------------------
from sdk.message.google.timestamp import Timestamp as TypesTimestamp
from  bindings.python.services import control_service_pb2 as ctrl_pb
from  bindings.python.services import control_service_pb2_grpc as ctrl_rpc


# =============================================================================
# Shared helpers
# =============================================================================
_channel: Optional[grpc.aio.Channel] = None
_stub: Optional[ctrl_rpc.ControlStub] = None

async def get_stub() -> ctrl_rpc.ControlStub:
    """Return a singleton ControlStub (creates the channel once)."""
    global _channel, _stub
    if _stub is None:
        # Change to secure_channel(...) if you’re using TLS.
        _channel = grpc.aio.insecure_channel("localhost:50051")
        await _channel.channel_ready()
        _stub = ctrl_rpc.ControlStub(_channel)  # NOTE: service “Control” -> ControlStub
    return _stub


def _stamp_now(req_pb: Any) -> None:
    """set timestamp to 'now'."""
    ts = ProtoTimestamp()
    ts.GetCurrentTime()
    req_pb.request.timestamp.CopyFrom(ts)


def _norm(value: Any) -> Any:
    """Normalize dataclasses/Enums/collections → plain types for ParseDict."""
    if isinstance(value, Enum):
        return int(value.value)  # ParseDict accepts enum numbers
    if is_dataclass(value):
        return {k: _norm(v) for k, v in dc_asdict(value).items()}
    if isinstance(value, dict):
        return {k: _norm(v) for k, v in value.items()}
    if isinstance(value, (list, tuple)):
        return [_norm(v) for v in value]
    return value


def _payload_from_action(action: Any, *, exclude: Tuple[str, ...] = ()) -> dict:
    """
    Build a dict from the action’s annotated fields (minus internal flags).
    Generator-friendly: you don’t need to list fields manually per RPC.
    """
    ann = getattr(action, "__annotations__", {}) or {}
    raw = {
        k: getattr(action, k)
        for k in ann.keys()
        if k not in exclude and hasattr(action, k) and getattr(action, k) is not None
    }
    return _norm(raw)


def _to_common_response(resp_pb: Any) -> CommonResponse:
    """
    Convert any <...Response> proto (with .response holding common.Response)
    into your types.common.Response (CommonResponse).
    """
    inner = getattr(resp_pb, "response", None)
    status = ResponseStatus(getattr(inner, "status"))
    msg = getattr(inner, "response_string", "") or getattr(inner, "message", "")
    ts = TypesTimestamp(  # type: ignore
                seconds=inner.timestamp.seconds,
                nanos=inner.timestamp.nanos,
            )

    return CommonResponse(status=status, response_string=msg, timestamp=ts)


async def _run_unary(method_coro, req_pb, *, metadata=None, timeout=None) -> CommonResponse:
    """Unary RPC -> CommonResponse."""
    _stamp_now(req_pb)
    resp_pb = await method_coro(req_pb, metadata=metadata, timeout=timeout)
    return _to_common_response(resp_pb)


async def _run_streaming(method_coro, req_pb, *, metadata=None, timeout=None) -> CommonResponse:
    """Server-streaming RPC -> drain and return last response as CommonResponse."""
    _stamp_now(req_pb)
    call = method_coro(req_pb, metadata=metadata, timeout=timeout)
    last = None
    async for msg in call:
        last = msg
    if last is None:
        # synthesize an empty-shaped response of the right type if stream was empty
        empty = ctrl_pb.TakeOffResponse()  # any response type with `.response` field works
        return _to_common_response(empty)
    return _to_common_response(last)

# =============================================================================
# Per-RPC actions (each returns CommonResponse)
# =============================================================================

@register_action
class Connect(Action):
    """Connects to the vehicle"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.ConnectRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.Connect, req)


@register_action
class IsConnected(Action):
    """Checks whether the vehicle is successfully connected"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.IsConnectedRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.IsConnected, req)


@register_action
class Disconnect(Action):
    """Disconnects from the vehicle"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.DisconnectRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.Disconnect, req)


@register_action
class Arm(Action):
    """Order the vehicle to arm"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.ArmRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.Arm, req)


@register_action
class Disarm(Action):
    """Order the vehicle to disarm"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.DisarmRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.Disarm, req)


@register_action
class TakeOff(Action):
    """Order the vehicle to take off"""
    take_off_altitude: float  # meters (relative altitude)

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.TakeOffRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.TakeOff, req)


@register_action
class Land(Action):
    """Land the vehicle at its current position"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.LandRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.Land, req)


@register_action
class Hold(Action):
    """Order the vehicle to hold/loiter"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.HoldRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.Hold, req)


@register_action
class Kill(Action):
    """Emergency shutdown of the vehicle motors"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.KillRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.Kill, req)


@register_action
class SetHome(Action):
    """Changes the home destination for the vehicle"""
    location: Location  # new home location

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetHomeRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.SetHome, req)


@register_action
class ReturnToHome(Action):
    """Return to the vehicle home destination"""

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.ReturnToHomeRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.ReturnToHome, req)


@register_action
class SetGlobalPosition(Action):
    """Transit the vehicle to a target global position, expressed in global coordinates"""
    location: Location
    altitude_mode: Optional[AltitudeMode] = None
    heading_mode: Optional[HeadingMode] = None
    max_velocity: Optional[Velocity] = None

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetGlobalPositionRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.SetGlobalPosition, req)


@register_action
class SetRelativePosition(Action):
    """Transit the vehicle to a target position relative to ENU or BODY frame, in meters"""
    position: Position
    max_velocity: Optional[Velocity] = None
    frame: ReferenceFrame = ReferenceFrame.BODY

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetRelativePositionRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.SetRelativePosition, req)


@register_action
class SetVelocity(Action):
    """Transit the vehicle at a target velocity in ENU or BODY frame, in m/s"""
    velocity: Velocity
    frame: ReferenceFrame = ReferenceFrame.BODY

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetVelocityRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.SetVelocity, req)


@register_action
class SetHeading(Action):
    """Sets the heading of the vehicle"""
    location: Location  # target heading or global location to look at
    heading_mode: HeadingMode

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetHeadingRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.SetHeading, req)


@register_action
class SetGimbalPose(Action):
    """Set the pose of the target gimbal"""
    gimbal_id: int
    pose: Pose
    mode: Optional[PoseMode] = None

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.SetGimbalPoseRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_streaming(stub.SetGimbalPose, req)


@register_action
class ConfigureImagingSensorStream(Action):
    """Set the vehicle video stream parameters"""
    configurations: List[ImagingSensorConfiguration]

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.ConfigureImagingSensorStreamRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.ConfigureImagingSensorStream, req)


@register_action
class ConfigureTelemetryStream(Action):
    """Set the vehicle telemetry stream parameters"""
    frequency: int  # Hz

    async def execute(self):
        stub = await get_stub()
        req = ctrl_pb.ConfigureTelemetryStreamRequest()
        ParseDict(_payload_from_action(self), req)
        return await _run_unary(stub.ConfigureTelemetryStream, req)
